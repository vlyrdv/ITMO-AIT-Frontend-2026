# Лабораторная работа 2 - Взаимодействие с внешним API

## Цель работы
Интегрировать ранее свёрстанное приложение с API, реализовать получение и отправку данных, а также продемонстрировать работу пользовательских сценариев, связанных с данными.

## Основа проекта
Для выполнения лабораторной работы был использован мой проект **movavifest**. В нём серверная часть построена на Node.js и Express, а данные берутся из локальной базы SQLite. Дополнительно в проекте реализована интеграция с внешним API для проведения оплаты.

Используемый стек:
- Node.js
- Express
- SQLite
- axios
- express-session
- Handlebars

## Работа с локальными данными
В проекте реализованы функции для получения и записи данных в SQLite. Они используются как основа серверной логики и выполняют роль внутреннего API-прослойки.

Пример получения данных:

```js
async function get_data(sql = "SELECT * FROM products", mass) {
  let db = new sqlite.Database("berry.db");
  let promise = new Promise((res, rej) => {
    db.all(sql, mass, (err, rows) => err ? rej(err) : res(rows));
  });
  let data = await promise;
  db.close();
  return data;
}
```

Пример записи данных:

```js
async function insert_data(sql, mass) {
  let db = new sqlite.Database("berry.db");
  let promise = new Promise((res, rej) => {
    db.run(sql, mass, function (err) {
      if (err) rej(err);
      else res(this);
    });
  });
  let result = await promise;
  db.close();
  return result;
}
```

За счёт этого в приложении можно:
- получать каталог товаров
- выполнять поиск
- работать с корзиной
- хранить заказы
- хранить пользовательские данные

## Интеграция с внешним API
Для демонстрации взаимодействия с внешним API в проекте реализована отправка запроса на платёжный сервис через библиотеку `axios`.

Типовой пример запроса:

```js
const payload = {
  amount: total,
  description: "Оплата заказа"
};

const result = await axios.post(
  "https://api.capusta.space/v1/partner/payment",
  payload,
  {
    headers: {
      Authorization: `Bearer ${process.env.PAYMENT_TOKEN}`
    }
  }
);
```

Таким образом, приложение не только отображает данные, но и взаимодействует с внешним сервисом, передавая информацию о заказе.

## Что именно было реализовано
В рамках ЛР2 были реализованы следующие сценарии:
- получение данных о товарах с сервера
- поиск по товарам
- добавление товаров в корзину
- подсчёт итоговой суммы
- хранение текущего состояния пользователя в сессии
- отправка данных заказа на внешний платёжный API

## Авторизация и сессии
В приложении используется `express-session`, что позволяет хранить временные данные пользователя между запросами.

Пример инициализации сессии:

```js
app.use((req, res, next) => {
  if (!req.session.visit) {
    req.session.visit = 1;
    req.session.cart = [];
    req.session.like = [];
    req.session.islogin = 0;
  }
  next();
});
```

Это используется для:
- хранения корзины
- хранения избранного
- определения факта авторизации
- отслеживания пользовательского сценария

## Отображение результатов в интерфейсе
Результаты API-интеграции отображаются в уже свёрстанных страницах:
- список товаров в каталоге
- результаты поиска
- содержимое корзины
- итоговая стоимость заказа
- переход к оплате / подтверждение оформления

Пример вывода корзины:

```hbs
{{#if data}}
  Стоимость всех продуктов в корзине: {{summ}}р
{{else}}
  Стоимость всех продуктов в корзине: 0р
{{/if}}
```

## Что приложить к отчёту
В итоговый PR рекомендуется приложить скриншоты:
1. Каталог с загруженными данными
2. Поиск по товарам
3. Корзина с итоговой суммой
4. Страница оформления заказа
5. Результат успешного взаимодействия с API
6. Network-запросы в DevTools (по желанию)

## Важное замечание
Секретные ключи и токены внешних сервисов не должны храниться прямо в коде. Для корректной практики их необходимо выносить в `.env` и получать через `process.env`.

## Вывод
В рамках лабораторной работы была реализована полноценная интеграция приложения с источниками данных: локальной базой SQLite и внешним платёжным API. За счёт этого приложение стало не только визуально оформленным, но и функциональным с точки зрения бизнес-логики и пользовательских действий.
